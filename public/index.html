<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Favicon (.ico, 32x32) -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">

    <!-- Open Graph / Social Media Meta Tags -->
    <meta property="og:title" content="Portugal Electricity Consumption Mix">
    <meta property="og:description" content="Portugal's electricity consumption taking imports into account.">
    <meta property="og:image" content="https://portugal-electricity-mix.vercel.app/og-image.jpg">
    <!-- 1200x630, jpg or png -->
    <meta property="og:url" content="https://portugal-electricity-mix.vercel.app">
    <meta property="og:type" content="website">

    <!-- SEO -->
    <link rel="alternate" hreflang="en" href="https://portugal-electricity-mix.vercel.app/" />
    <link rel="alternate" hreflang="pt" href="https://portugal-electricity-mix.vercel.app/" />

    <meta name="description"
        content="Portugal's electricity consumption, including imports. Consumo de eletricidade em Portugal: mix elétrico, energia elétrica e contribuições das importações.">


    <!-- Validation -->
    <meta name="google-site-verification" content="gT-Wvv_yWs2-IV3ZnDhnjYsK31nyTMvbrF34_Tb1yzE" />
    <meta name="msvalidate.01" content="B9750948FEDB6C5AB8EB0E4A736E5420" />

    <!-- Packages -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <!-- <script src="https://d3js.org/d3.v7.min.js"></script> -->

    <!-- Twitter Card tags -->
    <!-- <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Portugal Electricity Consumption Mix">
    <meta name="twitter:description" content="Analyze and visualize Portugal's electricity consumption patterns and energy mix">
    <meta name="twitter:image" content="https://your-domain.vercel.app/og-image.png"> -->

    <title>Portugal Electricity Consumption Mix</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .form-container {
            margin-bottom: 20px;
            padding: 20px;
            background-color: #f5f5f5;
            border-radius: 5px;
        }

        .error-message {
            color: #721c24;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            display: none;
        }

        .error-item {
            margin: 5px 0;
        }

        .loading {
            display: none;
            margin-top: 10px;
            color: #666;
        }

        button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        input[type="datetime-local"] {
            padding: 5px;
            margin-right: 10px;
        }


        /* #plotContainer {
            display: flex;
            justify-content: center;
            max-width: 100%;
            width: auto;
            height: 70vh;
            margin: 20px 0;
        } */

        #plotContainer {
            width: 100%;
            height: 90vh;
            /* Adjust as needed */
            margin: 20px 0;
        }

        /* #plotContainer>div {
            width: 100% !important;
            height: 100% !important;
        } */

        .plot-container.plotly {
            justify-items: center;
        }

        /* #plotContainer img {
            max-width: 100%;
            width: auto;
            height: 80vh;
            margin: 20px 0;
        } */

        .time-field {
            margin: 10px 0;
        }

        .help-text {
            font-size: 0.8em;
            color: #666;
        }

        .inline-help-text {
            font-size: 0.8em;
            color: #666;
            display: inline;
            margin-left: 5px;
            cursor: help;
            position: relative;
        }

        .inline-help-text:hover::after {
            content: "Hovering over the plot will show all details.";
            position: absolute;
            background-color: #333;
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            white-space: nowrap;
            left: 50%;
            transform: translateX(-50%);
            bottom: 125%;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s;
            z-index: 1000;
        }

        .inline-help-text:hover::after {
            opacity: 1;
            visibility: visible;
        }

        /* Style labels of disabled radio buttons */
        input[name="timeMode"]:disabled+label {
            color: #cccccc;
            cursor: not-allowed;
        }

        .mode-selector {
            margin-bottom: 20px;
        }

        #advancedControls .time-field input {
            width: 300px;
            padding: 5px;
        }

        .plot-type-selector {
            margin-bottom: 20px;
            padding: 10px;
            background-color: #fff;
            border-radius: 4px;
        }

        .plot-type-selector label {
            margin-right: 15px;
        }
    </style>
    <!-- Comment out Bokeh scripts and styles -->
    <!--
    <link href="https://cdn.bokeh.org/bokeh/release/bokeh-3.3.4.min.css" rel="stylesheet">
    <link href="https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.3.4.min.css" rel="stylesheet">
    <script src="https://cdn.bokeh.org/bokeh/release/bokeh-3.3.4.min.js"></script>
    <script src="https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.3.4.min.js"></script>
    -->
</head>

<body>
    <div id="header"></div>
    <h1>Portugal Electricity Consumption Mix</h1>

    <div class="form-container">
        <!-- <div class="plot-type-selector"> -->
        <div class="mode-selector">
            <input type="radio" id="discriminated" name="plotMode" value="discriminated" checked>
            <label for="discriminated">Average by Country and Source</label>
            <input type="radio" id="aggregated" name="plotMode" value="aggregated">
            <label for="aggregated">Average by Source</label>
            <input type="radio" id="areas" name="plotMode" value="areas">
            <label for="areas">Time-based Chart</label>
        </div>

        <div class="mode-selector">
            <input type="radio" id="simpleMode" name="timeMode" value="simple" checked>
            <label for="simpleMode">Simple Interval</label>
            <input type="radio" id="advancedMode" name="timeMode" value="advanced">
            <label for="advancedMode">Complex Interval</label>
        </div>



        <form id="plotForm">
            <div id="simpleControls">
                <label for="start_date">Start Date (UTC):</label>
                <input type="datetime-local" id="start_date" required value="2024-01-01T00:00" step="3600"
                    min="2015-01-15T00:00">

                <label for="end_date">End Date (UTC):</label>
                <input type="datetime-local" id="end_date" required value="2024-01-01T02:00" step="3600"
                    min="2015-01-15T01:00">
            </div>

            <div id="advancedControls" style="display: none;">
                <div class="time-field">
                    <!-- <span>Empty fields means no constraints (all years considered). Ranges (eg. 2020-2023) are inclusive</span><br><br> -->
                    <label for="years">Years:</label>
                    <input type="text" id="years" placeholder="e.g., 2015, 2017, 2020-2023">
                    <span class="help-text">Empty means no constraint (all years considered). Ranges (eg. 2020-2023) are
                        inclusive</span>
                </div>
                <div class="time-field">
                    <label for="months">Months:</label>
                    <input type="text" id="months" placeholder="e.g., 1-3, 3, 6, 9">
                    <span class="help-text">Same as above</span>
                </div>
                <div class="time-field">
                    <label for="days">Days:</label>
                    <input type="text" id="days" placeholder="e.g., 1-15, 20, 22-25">
                    <span class="help-text">Same as above</span>
                </div>
                <div class="time-field">
                    <label for="hours">Hours:</label>
                    <input type="text" id="hours" placeholder="e.g., 20-23, 23-2">
                    <span class="help-text">
                        Valid values: [0, 23]. (UTC timezone!)
                        <br>Each selected hour represents the interval from that hour's start, till the start of the
                        next hour.
                        <br>5 represents the interval from 5am-6am
                        <br>14-17 represents the interval 2pm-6pm.</span>
                </div>
            </div>
            <button type="submit" id="submitBtn">Generate Plot</button>
        </form>
        <div id="errorMessage" class="error-message"></div>
        <div id="loading" class="loading">Generating visualization...<br>(May take up to 60s if fetching new data is
            required)</div>
        <!-- <div id="cacheWarning" class="error-message" style="display: none;">
            Warning: Data cache is empty. Please initialize the cache before proceeding.  <button id="initializeCacheBtn">Initialize Cache</button>
        </div> -->
    </div>

    <script>
        const PSR_TYPE_MAPPING = {
            "B01": "Biomass",
            "B02": "Fossil Brown coal/Lignite",
            "B03": "Fossil Coal-derived gas",
            "B04": "Fossil Gas",
            "B05": "Fossil Hard coal",
            "B06": "Fossil Oil",
            "B07": "Fossil Oil shale",
            "B08": "Fossil Peat",
            "B09": "Geothermal",
            "B10": "Hydro Pumped Storage",
            "B11": "Hydro Run-of-river and poundage",
            "B12": "Hydro Water Reservoir",
            "B13": "Marine",
            "B14": "Nuclear",
            "B15": "Other renewable",
            "B16": "Solar",
            "B17": "Waste",
            "B18": "Wind Offshore",
            "B19": "Wind Onshore",
            "B20": "Other",
        };

        class JsonDataParser {
            constructor(jsonData) {
                this.data = JSON.parse(jsonData);
            }

            get index() {
                return this.data.index.map(ts => new Date(ts));
            }

            get columns() {
                return this.data.columns;
            }



            get values() {
                return this.data.data;
            }

            mean() {
                const numRows = this.values.length;
                if (numRows === 0) return new Map();

                const numCols = this.columns.length;
                const sums = new Array(numCols).fill(0);

                for (let i = 0; i < numRows; i++) {
                    for (let j = 0; j < numCols; j++) {
                        sums[j] += this.values[i][j];
                    }
                }

                const means = new Map();
                for (let j = 0; j < numCols; j++) {
                    means.set(this.columns[j], sums[j] / numRows);
                }
                return means;
            }
        }

        class Plotter {
            constructor(data) {
                this.aggregated = new JsonDataParser(data.aggregated);
                this.contributions = {};
                for (const country in data.contributions) {
                    this.contributions[country] = new JsonDataParser(data.contributions[country]);
                }
            }

            plot(plotMode, timeMode, startDate, endDate) {
                switch (plotMode) {
                    case 'aggregated':
                        return this._plotAggregated(timeMode, startDate, endDate);
                    case 'discriminated':
                        return this._plotHierarchical(timeMode, startDate, endDate);
                    case 'areas':
                        return this._plotAreas(timeMode, startDate, endDate);
                    default:
                        throw new Error(`Unsupported plot mode: ${plotMode}`);
                }
            }

            _plotAggregated(timeMode, startDate, endDate) {
                const data = this.aggregated.mean();
                const plotData = [];
                const labels = [];
                const values = [];

                data.forEach((value, key) => {
                    if (value > 0) {
                        labels.push(PSR_TYPE_MAPPING[key] || key);
                        values.push(value);
                    }
                });

                const total = values.reduce((a, b) => a + b, 0);
                const percentages = values.map(v => (v / total) * 100);

                const trace = {
                    type: 'pie',
                    labels: labels,
                    values: values,
                    customdata: percentages.map(p => [p]),
                    textinfo: 'percent+label',
                    texttemplate: '%{label}<br>%{customdata[0]:.1f}% | %{value:.1f} MW',
                    hovertemplate: '%{label}<br>%{customdata[0]:.1f}% | %{value:.1f} MW',
                    hole: 0,
                    insidetextorientation: 'auto',
                };

                let title = "Portugal Electricity Consumption Mix";
                if (timeMode === 'simple' && startDate && endDate) {
                    const formattedStartDate = this._formatDateTime(startDate, false, endDate);
                    const formattedEndDate = this._formatDateTime(endDate, true);
                    if (formattedStartDate === formattedEndDate) {
                        title += ` (${formattedStartDate})`;
                    } else {
                        title += ` (${formattedStartDate} - ${formattedEndDate})`;
                    }
                }

                const layout = {
                    title: title,
                    showlegend: false,
                    width: 900,
                    height: 800,
                    autosize: true,
                    annotations: [
                        {
                            text: "Source: https://portugal-electricity-mix.vercel.app<br>Data: ENTSO-E (European Network of Transmission System Operators for Electricity)",
                            showarrow: false,
                            x: 0.5,
                            y: -0.1,
                            xref: 'paper',
                            yref: 'paper',
                            xanchor: 'center',
                            yanchor: 'top',
                        }
                    ],
                    margin: { t: 50, b: 100, l: 0, r: 0 },
                };

                return { data: [trace], layout: layout };
            }

            _plotHierarchical(timeMode, startDate, endDate) {
                const records = [];
                const totalHours = this.aggregated.index.length;
                const dataByCountryTimeAggregated = {};
                let totalPower = 0;

                for (const country in this.contributions) {
                    const meanData = this.contributions[country].mean();
                    dataByCountryTimeAggregated[country] = meanData;
                    meanData.forEach(value => totalPower += value);
                }

                for (const country in dataByCountryTimeAggregated) {
                    const series = dataByCountryTimeAggregated[country];
                    let countryPower = 0;
                    series.forEach(value => countryPower += value);
                    const countryEnergy = countryPower * totalHours;
                    const percentage = (countryPower / totalPower) * 100;

                    records.push({
                        id: country,
                        parent: "",
                        label: country,
                        power: countryPower,
                        percentage: percentage,
                        hover_text: `<b>${country}</b><br>${percentage.toFixed(1)}% of total<br>${countryPower.toFixed(0)} MW (average)<br>${this._calcEnergyString(countryEnergy)}`
                    });

                    series.forEach((power, source_type) => {
                        if (power > 0) {
                            const sourceName = PSR_TYPE_MAPPING[source_type] || source_type;
                            const energy = power * totalHours;
                            const sourcePercentage = (power / totalPower) * 100;
                            const id = `${country}/${sourceName}`;
                            records.push({
                                id: id,
                                parent: country,
                                label: sourceName,
                                power: power,
                                percentage: sourcePercentage,
                                hover_text: `<b>${id}</b><br>${(power / countryPower * 100).toFixed(1)}% of ${country}<br>${sourcePercentage.toFixed(1)}% of total<br>${power.toFixed(0)} MW (average)<br>${this._calcEnergyString(energy)}`
                            });
                        }
                    });
                }

                const trace = {
                    type: 'sunburst',
                    ids: records.map(r => r.id),
                    labels: records.map(r => r.label),
                    parents: records.map(r => r.parent),
                    values: records.map(r => r.power),
                    customdata: records.map(r => [r.percentage, r.hover_text]),
                    insidetextorientation: 'radial',
                    hovertemplate: '%{customdata[1]}<extra></extra>',
                    branchvalues: 'total',
                };

                let title = "Portugal Electricity Consumption Mix";
                if (timeMode === 'simple' && startDate && endDate) {
                    const formattedStartDate = this._formatDateTime(startDate, false, endDate);
                    const formattedEndDate = this._formatDateTime(endDate, true);
                    if (formattedStartDate === formattedEndDate) {
                        title += ` (${formattedStartDate})`;
                    } else {
                        title += ` (${formattedStartDate} - ${formattedEndDate})`;
                    }
                }

                const layout = {
                    title: title,
                    width: 700,
                    height: 800,
                    autosize: true,
                    annotations: [
                        {
                            text: "Source: https://portugal-electricity-mix.vercel.app<br>Data: ENTSO-E (European Network of Transmission System Operators for Electricity)",
                            showarrow: false,
                            x: 0.5,
                            y: -0.1,
                            xref: 'paper',
                            yref: 'paper',
                            xanchor: 'center',
                            yanchor: 'top',
                        }
                    ],
                    margin: { t: 50, b: 100, l: 0, r: 0 },
                };

                return { data: [trace], layout: layout };
            }

            _plotAreas(timeMode, startDate, endDate) {
                const traces = [];
                const index = this.aggregated.index;
                const columns = this.aggregated.columns;
                const values = this.aggregated.values;

                for (let j = 0; j < columns.length; j++) {
                    const colName = columns[j];
                    const yValues = values.map(row => row[j]);
                    traces.push({
                        x: index,
                        y: yValues,
                        name: PSR_TYPE_MAPPING[colName] || colName,
                        type: 'scatter',
                        mode: 'lines',
                        stackgroup: 'one',
                        hovertemplate: `<b>${PSR_TYPE_MAPPING[colName] || colName}</b><br>%{y:.0f} MW<extra></extra>`,
                    });
                }

                let title = "Portugal Electricity Consumption Mix";
                if (timeMode === 'simple' && startDate && endDate) {
                    const formattedStartDate = this._formatDateTime(startDate, false, endDate);
                    const formattedEndDate = this._formatDateTime(endDate, true);
                    if (formattedStartDate === formattedEndDate) {
                        title += ` (${formattedStartDate})`;
                    } else {
                        title += ` (${formattedStartDate} - ${formattedEndDate})`;
                    }
                }

                const layout = {
                    title: title,
                    xaxis: { title: 'Time' },
                    yaxis: { title: 'Power (MW)' },
                    autosize: true,
                    annotations: [
                        {
                            text: "Source: https://portugal-electricity-mix.vercel.app<br>Data: ENTSO-E (European Network of Transmission System Operators for Electricity)",
                            showarrow: false,
                            x: 0.5,
                            y: -0.1,
                            xref: 'paper',
                            yref: 'paper',
                            xanchor: 'center',
                            yanchor: 'top',
                        }
                    ],
                    margin: { t: 50, b: 100, l: 0, r: 0 },
                };

                return { data: traces, layout: layout };
            }

            _calcEnergyString(energyInMWh) {
                const GWh_FACTOR = 1000;
                const TWh_FACTOR = 1000000;
                let value, unit;

                if (energyInMWh >= TWh_FACTOR) {
                    value = energyInMWh / TWh_FACTOR;
                    unit = "TWh";
                } else if (energyInMWh >= GWh_FACTOR) {
                    value = energyInMWh / GWh_FACTOR;
                    unit = "GWh";
                } else {
                    value = energyInMWh;
                    unit = "MWh";
                }
                return `${value.toPrecision(4)} ${unit}`;
            }

            _formatDateTime(dateTimeString, isEndDate = false, endDateString = null) {
                const date = new Date(dateTimeString + 'Z'); // Append 'Z' to treat as UTC
                let day = date.getUTCDate();
                let month = date.getUTCMonth() + 1; // Months are 0-indexed
                let year = date.getUTCFullYear();
                let hours = date.getUTCHours();
                let minutes = date.getUTCMinutes();

                if (isEndDate && hours === 0 && minutes === 0) {
                    // If end date and time is 00:00, display previous day
                    date.setUTCDate(date.getUTCDate() - 1);
                    day = date.getUTCDate();
                    month = date.getUTCMonth() + 1;
                    year = date.getUTCFullYear();
                }

                const formattedDate = `${String(day).padStart(2, '0')}/${String(month).padStart(2, '0')}/${year}`;

                // Check for full day interval
                if (endDateString) {
                    const startDateObj = new Date(dateTimeString + 'Z');
                    const endDateObj = new Date(endDateString + 'Z');

                    const nextDay = new Date(startDateObj);
                    nextDay.setUTCDate(startDateObj.getUTCDate() + 1);
                    nextDay.setUTCHours(0, 0, 0, 0);

                    if (startDateObj.getUTCHours() === 0 && startDateObj.getUTCMinutes() === 0 &&
                        endDateObj.getTime() === nextDay.getTime()) {
                        return formattedDate; // Return only the date for full day intervals
                    }
                }

                if (hours === 0 && minutes === 0) {
                    return formattedDate;
                } else {
                    const ampm = hours >= 12 ? 'PM' : 'AM';
                    const formattedHours = hours % 12 === 0 ? 12 : hours % 12;
                    const formattedTime = `${formattedHours}${ampm}`;
                    return `${formattedDate} ${formattedTime}`;
                }
            }
        }


        // Add radio button change event handlers
        document.querySelectorAll('input[name="timeMode"]').forEach(radio => {
            radio.addEventListener('change', function () {
                const simpleControls = document.getElementById('simpleControls');
                const advancedControls = document.getElementById('advancedControls');
                const errorMessage = document.getElementById('errorMessage');
                const submitBtn = document.getElementById('submitBtn');

                if (this.value === 'simple') {
                    simpleControls.style.display = 'block';
                    advancedControls.style.display = 'none';
                    // Revalidate simple mode inputs
                    validateDates();
                } else {
                    simpleControls.style.display = 'none';
                    advancedControls.style.display = 'block';
                    // Clear any existing errors and enable submit button
                    errorMessage.style.display = 'none';
                    errorMessage.innerHTML = '';
                    submitBtn.disabled = false;
                }
            });
        });

        // Add event listener for 'plotMode' radio buttons
        document.querySelectorAll('input[name="plotMode"]').forEach(radio => {
            radio.addEventListener('change', function () {
                const advancedModeRadio = document.getElementById('advancedMode');
                const simpleModeRadio = document.getElementById('simpleMode');
                const advancedControls = document.getElementById('advancedControls');
                const errorMessage = document.getElementById('errorMessage');
                const submitBtn = document.getElementById('submitBtn');

                if (this.value === 'areas') {
                    // Automatically select Simple Interval
                    simpleModeRadio.checked = true;

                    simpleModeRadio.dispatchEvent(new Event('change'));

                    // Disable Advanced Interval
                    advancedModeRadio.disabled = true;

                    // Hide Advanced Controls
                    advancedControls.style.display = 'none';

                    // Clear any existing error messages
                    errorMessage.style.display = 'none';
                    errorMessage.innerHTML = '';
                } else {
                    // Enable Advanced Interval when not in 'areas' mode
                    advancedModeRadio.disabled = false;
                }
            });
        });


        function getDateBounds(dateTimeInput) {
            const minStartDate = new Date('2015-01-15T00:00Z');
            const maxEndDate = new Date();
            maxEndDate.setUTCHours(maxEndDate.getUTCHours() - 1, 0, 0, 0);

            const minEndDate = new Date(minStartDate);
            minEndDate.setUTCHours(minEndDate.getUTCHours() + 1);
            const maxStartDate = new Date(maxEndDate);
            maxStartDate.setUTCHours(maxStartDate.getUTCHours() - 1);
            return [minStartDate, minEndDate, maxStartDate, maxEndDate];
        }


        // Add this function after getCurrentUTCHour()
        function setFormDateBounds() {
            const [minStartDate, minEndDate, maxStartDate, maxEndDate] = getDateBounds();

            const startDateInput = document.getElementById('start_date');
            const endDateInput = document.getElementById('end_date');

            // Format dates to ISO string and slice to get the format required by datetime-local
            startDateInput.min = minStartDate.toISOString().slice(0, 16);
            endDateInput.min = minEndDate.toISOString().slice(0, 16);
            startDateInput.max = maxStartDate.toISOString().slice(0, 16);
            endDateInput.max = maxEndDate.toISOString().slice(0, 16);
        }


        // Modify the event listeners section to include 'input' events
        document.getElementById('start_date').addEventListener('input', function () {
            validateDates();
        });
        document.getElementById('start_date').addEventListener('change', function () {
            validateDates();
        });

        document.getElementById('end_date').addEventListener('input', function () {
            validateDates();
        });
        document.getElementById('end_date').addEventListener('change', function () {
            validateDates();
        });

        function validateDates() {
            const startDateInput = document.getElementById('start_date');
            const endDateInput = document.getElementById('end_date');
            const startDate = new Date(startDateInput.value + 'Z');
            const endDate = new Date(endDateInput.value + 'Z');

            let errors = [];

            // Check if either date is invalid (NaN)
            if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                errors.push("Please insert valid dates");
                const errorMessage = document.getElementById('errorMessage');
                errorMessage.innerHTML = errors.map(error => `<div class="error-item">${error}</div>`).join('');
                errorMessage.style.display = 'block';
                submitBtn.disabled = true;
                return false;
            }

            if (startDate.getUTCMinutes() !== 0) {
                errors.push("Start time must be on the hour (00 minutes)");
            }
            if (endDate.getUTCMinutes() !== 0) {
                errors.push("End time must be on the hour (00 minutes)");
            }

            const [minStartDate, minEndDate, maxStartDate, maxEndDate] = getDateBounds();

            console.log('Input start date:', startDate.toISOString());
            console.log('Min start date:', minStartDate.toISOString());
            console.log('Start date timestamp:', startDate.getTime());
            console.log('Min start date timestamp:', minStartDate.getTime());

            // Check date ranges
            if (startDate < minStartDate) {
                errors.push(`Start date cannot be earlier than ${minStartDate.toUTCString().replace("GMT", "UTC")}`);
            }

            if (endDate < minEndDate) {
                errors.push(`End date cannot be earlier than ${minEndDate.toUTCString().replace("GMT", "UTC")}`);
            }

            if (startDate > maxStartDate) {
                errors.push(`Start date cannot be later than ${maxStartDate.toUTCString().replace("GMT", "UTC")}`);
            }

            if (endDate > maxEndDate) {
                errors.push(`End date cannot be later than ${maxEndDate.toUTCString().replace("GMT", "UTC")}`);
            }

            // Check date order
            if (startDate >= endDate) {
                errors.push("End date must be after start date");
            }

            const plotMode = document.querySelector('input[name="plotMode"]:checked').value;

            if (plotMode == "areas") {
                const timeDifference = (endDate - startDate) / (1000 * 60 * 60);

                if (timeDifference < 2) {
                    errors.push("Time-based charts: Interval must span at least 2 hours.");
                }

                if (timeDifference > 7 * 24) {
                    errors.push("Time-based charts: Interval must span at most 7 days (168 hours).");
                }
            }

            // Display errors or hide error container
            const errorMessage = document.getElementById('errorMessage');
            if (errors.length > 0) {
                errorMessage.innerHTML = errors.map(error => `<div class="error-item">${error}</div>`).join('');
                errorMessage.style.display = 'block';
                submitBtn.disabled = true;
                return false;
            } else {
                errorMessage.innerHTML = '';
                errorMessage.style.display = 'none';
                submitBtn.disabled = false;
                return true;
            }
        }
    </script>

    <div id="plotContainer">
        <div id="plotControls" class="plot-controls" style="display: none;">
            <h3 style="margin-top: 0; margin-bottom: 10px">Plot Controls</h3>
            <div>
                <input type="checkbox" id="plotControlShowDetails" checked>
                <label for="plotControlShowDetails">
                    Show Details <span class="inline-help-text">(You can also hover for the plot for all details)</span>
                </label>
            </div>
            <div id="aggregateImportsContainer" style="display: none;">
                <input type="checkbox" id="plotControlAggregateImports">
                <label for="plotControlAggregateImports">Aggregate Imports</label>
            </div>
            <div>
                <label for="plotControlPlotSize">Plot Size:</label>
                <input type="range" id="plotControlPlotSize" min="400" max="1000" value="800" step="50">
                <!-- <span id="plotHeightValue">800px</span> -->
            </div>
        </div>
        <div id="plotArea"></div>
    </div>

    <div id="footer"></div>

    <!-- <div id="footer"></div> -->

    <script>
        // Load and insert the header
        fetch('/header.html')
            .then(response => response.text())
            .then(html => {
                document.getElementById('header').innerHTML = html;
            });

        // Load and insert the footer
        // fetch('/footer.html')
        //     .then(response => response.text())
        //     .then(html => {
        //         document.getElementById('footer').innerHTML = html;
        //     });

        async function submitForm(e) {
            e.preventDefault();

            const errorMessage = document.getElementById('errorMessage');
            const loading = document.getElementById('loading');
            const submitBtn = document.getElementById('submitBtn');
            const plotContainer = document.getElementById('plotContainer');

            errorMessage.style.display = 'none';
            loading.style.display = 'block';
            submitBtn.disabled = true;

            try {
                const mode = document.querySelector('input[name="timeMode"]:checked').value;
                const plotMode = document.querySelector('input[name="plotMode"]:checked').value;
                let requestData;

                if (mode === 'simple') {
                    requestData = {
                        mode: 'simple',
                        plot_mode: plotMode,
                        start_date: document.getElementById('start_date').value,
                        end_date: document.getElementById('end_date').value
                    };
                } else {
                    requestData = {
                        mode: 'advanced',
                        plot_mode: plotMode,
                        years: document.getElementById('years').value,
                        months: document.getElementById('months').value,
                        days: document.getElementById('days').value,
                        hours: document.getElementById('hours').value
                    };
                }

                console.log('API CALL');

                const response = await fetch('/api/generate_plot', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestData)
                });

                console.log("API CALL SENT");

                const textResponse = await response.text();
                console.log("API CALL RECEIVED", textResponse);
                let data;

                try {
                    data = JSON.parse(textResponse);
                } catch (parseError) {
                    throw new Error(textResponse || 'Invalid server response');
                }

                if (!response.ok) {
                    if (response.status == 504) {
                        throw new Error("Error: Backend timeout");
                    }
                    throw new Error(data.error || 'Failed to generate visualization');
                }

                if (data.data) {
                    document.getElementById('plotArea').innerHTML = '';
                    errorMessage.style.display = 'none';

                    window.plotter = new Plotter(data.data);

                    const timeMode = document.querySelector('input[name="timeMode"]:checked').value;
                    let startDate, endDate;
                    if (mode === 'simple') {
                        startDate = document.getElementById('start_date').value;
                        endDate = document.getElementById('end_date').value;
                    }

                    window.generatedPlotMode = plotMode;
                    window.currentPlotData = window.plotter.plot(plotMode, timeMode, startDate, endDate);

                    updatePlot();

                    document.getElementById('plotControls').style.display = 'block';

                    plotContainer.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                } else {
                    throw new Error('No plot data received');
                }

            } catch (error) {
                errorMessage.innerHTML = `<div class="error-item">${error.message}</div>`;
                errorMessage.style.display = 'block';
                document.getElementById('plotArea').innerHTML = '';

                document.getElementById('plotControls').style.display = 'none';

                console.error('Error:', error);
            } finally {
                loading.style.display = 'none';
                submitBtn.disabled = false;
            }
        }

        // Add event listener for form submission
        document.getElementById('plotForm').addEventListener('submit', submitForm);

        // Add this event listener at the end of your script section
        window.addEventListener('load', function () {
            setFormDateBounds();
            validateDates();

            const selectedPlotMode = document.querySelector('input[name="plotMode"]:checked');
            if (selectedPlotMode) {
                selectedPlotMode.dispatchEvent(new Event('change'));
            }
        });

        let lastViewportWidth = window.innerWidth;
        let lastViewportHeight = window.innerHeight;
        let lastZoomLevel = window.devicePixelRatio;

        window.addEventListener('resize', () => {
            const currentViewportWidth = window.innerWidth;
            const currentViewportHeight = window.innerHeight;
            const currentZoomLevel = window.devicePixelRatio;

            if (currentZoomLevel !== lastZoomLevel) {
                console.log('Zoom level changed, ignoring resize');
                lastZoomLevel = currentZoomLevel;
                return;
            }

            if (currentViewportWidth !== lastViewportWidth || currentViewportHeight !== lastViewportHeight) {
                console.log('Viewport size changed:', currentViewportWidth, currentViewportHeight);

                const plotContainer = document.getElementById('plotContainer');
                if (plotContainer.children.length > 0) {
                    Plotly.Plots.resize('plotArea');
                }

                lastViewportWidth = currentViewportWidth;
                lastViewportHeight = currentViewportHeight;
            }
        });

        // Function to update plot based on current controls
        function updatePlot() {
            if (!window.currentPlotData) return;

            const plotMode = document.querySelector('input[name="plotMode"]:checked').value;
            const aggregateImportsContainer = document.getElementById('aggregateImportsContainer');

            if (window.generatedPlotMode === 'discriminated') {
                aggregateImportsContainer.style.display = 'block';
            } else {
                aggregateImportsContainer.style.display = 'none';
            }

            const data = structuredClone(window.currentPlotData.data);
            const layout = structuredClone(window.currentPlotData.layout);

            const aggregateImports = document.getElementById('plotControlAggregateImports').checked;

            if (plotMode === 'discriminated' && aggregateImports) {
                const totalValue = data[0].values.reduce((sum, v, i) => data[0].parents[i] === '' ? sum + v : sum, 0);

                const aggregatedData = {
                    ids: [],
                    labels: [],
                    parents: [],
                    values: [],
                    customdata: [],
                    marker: { colors: [] }
                };
                const imports = {
                    id: "Imports",
                    label: "Imports",
                    parent: "",
                    value: 0,
                    twh: 0,
                    color: "#fdb462"
                };
                const importSources = {};

                for (let i = 0; i < data[0].ids.length; i++) {
                    const id = data[0].ids[i];
                    const label = data[0].labels[i];
                    const parent = data[0].parents[i];
                    const value = data[0].values[i];
                    const customdata = data[0].customdata[i];

                    let twh = 0;
                    const match = customdata[1].match(/<br>([\d.]+) (T|G)Wh/);
                    if (match) {
                        const num = parseFloat(match[1]);
                        const unit = match[2];
                        twh = unit === 'G' ? num / 1000 : num;
                    }

                    if (parent === "" && id !== "PT") {
                        imports.value += value;
                        imports.twh += twh;
                    } else if (id.startsWith("PT")) {
                        aggregatedData.ids.push(id);
                        aggregatedData.labels.push(label);
                        aggregatedData.parents.push(parent);
                        aggregatedData.values.push(value);
                        aggregatedData.customdata.push(customdata);
                    } else {
                        if (!importSources[label]) {
                            importSources[label] = {
                                id: `Imports/${label}`,
                                label: label,
                                parent: "Imports",
                                value: 0,
                                twh: 0
                            };
                        }
                        importSources[label].value += value;
                        importSources[label].twh += twh;
                    }
                }

                const importsPercentOfTotal = (imports.value / totalValue) * 100;
                let importsEnergyValue = imports.twh;
                let importsEnergyUnit = "TWh";
                if (importsEnergyValue < 1 && importsEnergyValue > 0) {
                    importsEnergyValue *= 1000;
                    importsEnergyUnit = "GWh";
                }
                imports.customdata = [
                    importsPercentOfTotal,
                    `<b>Imports</b><br>${importsPercentOfTotal.toFixed(1)}% of total<br>${Math.round(imports.value)} MW (average)<br>${importsEnergyValue.toFixed(1)} ${importsEnergyUnit}`
                ];

                aggregatedData.ids.push(imports.id);
                aggregatedData.labels.push(imports.label);
                aggregatedData.parents.push(imports.parent);
                aggregatedData.values.push(imports.value);
                aggregatedData.customdata.push(imports.customdata);

                for (const source in importSources) {
                    const sourceData = importSources[source];
                    const percentOfImports = (sourceData.value / imports.value) * 100;
                    const percentOfTotal = (sourceData.value / totalValue) * 100;

                    let energyValue = sourceData.twh;
                    let energyUnit = "TWh";
                    if (energyValue < 1 && energyValue > 0) {
                        energyValue *= 1000;
                        energyUnit = "GWh";
                    }

                    sourceData.customdata = [
                        percentOfTotal,
                        `<b>Imports/${sourceData.label}</b><br>${percentOfImports.toFixed(1)}% of Imports<br>${percentOfTotal.toFixed(1)}% of total<br>${Math.round(sourceData.value)} MW (average)<br>${energyValue.toFixed(1)} ${energyUnit}`
                    ];

                    aggregatedData.ids.push(sourceData.id);
                    aggregatedData.labels.push(sourceData.label);
                    aggregatedData.parents.push(sourceData.parent);
                    aggregatedData.values.push(sourceData.value);
                    aggregatedData.customdata.push(sourceData.customdata);
                }

                data[0] = {
                    ...data[0],
                    ...aggregatedData
                };
            }

            // Change plotSize
            layout.height = parseInt(document.getElementById('plotControlPlotSize').value);
            delete layout.width;

            // Change text template
            const showDetails = document.getElementById('plotControlShowDetails').checked;
            if (showDetails) {
                if (data[0].type == "pie")
                    data[0].texttemplate = "%{label}<br>%{customdata[0]:.1f}% | %{value:.1f} MW"
                else if (data[0].type == "sunburst")
                    data[0].texttemplate = "%{label}<br>%{customdata[0]:.1f}%";
            }
            else {
                data[0].texttemplate = "%{label}";
            }

            //Change color
            if (data[0].type === "sunburst") {
                const colors = {
                    "PT": "#80b1d3",
                    "ES": "#fb8072",
                    "FR": "#b3de69",
                    "Imports": "#fdb462"
                };

                if (!data[0].marker) {
                    data[0].marker = {};
                }

                data[0].marker.colors = data[0].labels.map((label, i) => {
                    const parent = data[0].parents[i];
                    if (parent === "") {
                        return colors[label];
                    }
                    return null;
                });
            }

            if (data[0].type === "scatter") {
                layout.hovermode = "x";
                layout.hoverlabel = { namelength: -1 };
                layout.xaxis = { showspikes: true }
            }

            Plotly.newPlot('plotArea', data, layout, { responsive: false });
        }

        // Setup plot control event listeners
        document.getElementById('plotControlShowDetails').addEventListener('change', updatePlot);
        document.getElementById('plotControlAggregateImports').addEventListener('change', updatePlot);
        document.getElementById('plotControlPlotSize').addEventListener('input', function () {
            // document.getElementById('plotHeightValue').textContent = this.value + 'px';
            updatePlot();
        });

        document.querySelectorAll('input[name="plotMode"]').forEach(radio => {
            radio.addEventListener('change', updatePlot);
        });

        window.onbeforeunload = function () {
            window.scrollTo(0, 0);
        }

    </script>
</body>

</html>
